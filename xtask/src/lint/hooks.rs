use super::error::{LintError, Result};
use crate::prelude::*;
use std::fs;
use std::os::unix::fs::PermissionsExt;
use std::path::{Path, PathBuf};

const HOOK_TEMPLATE: &str = r#"#!/usr/bin/env bash
set -eu

# peon-ping Pre-commit Hook
# This hook runs code quality checks before allowing commits
# Generated by: cargo xtask lint --install-hooks

# Get the project root
PROJECT_ROOT="$(git rev-parse --show-toplevel)"

# Change to project root
cd "$PROJECT_ROOT"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Log functions
log_info() {
    echo -e "${BLUE}[pre-commit]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[pre-commit]${NC} ‚úÖ $1"
}

log_error() {
    echo -e "${RED}[pre-commit]${NC} ‚ùå $1"
}

# Check if there are any staged Rust files
STAGED_RS_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.rs$' || true)

if [[ -z "$STAGED_RS_FILES" ]]; then
    log_info "No staged Rust files found. Skipping Rust checks."
    exit 0
fi

log_info "Found staged Rust files:"
echo "$STAGED_RS_FILES" | sed 's/^/  - /'
echo

# Parse arguments
FORCE_MODE=false
for arg in "$@"; do
    case $arg in
        --force|-f)
            FORCE_MODE=true
            shift
            ;;
    esac
done

# Run lint checks via xtask
log_info "Running code quality checks..."
echo

if [[ "$FORCE_MODE" == true ]]; then
    cargo xtask lint --force
else
    cargo xtask lint --staged-only
fi

EXIT_CODE=$?

if [[ $EXIT_CODE -eq 0 ]]; then
    echo
    log_success "All pre-commit checks passed! üéâ"
    log_info "Commit proceeding..."
else
    echo
    log_error "Pre-commit checks failed!"
    log_error "Commit aborted. Please fix the issues above and try again."
    echo
    log_info "Quick fixes:"
    log_info "  ‚Ä¢ cargo xtask lint --fix  - Auto-fix issues"
    log_info "  ‚Ä¢ cargo clippy --fix      - Fix clippy warnings"
    log_info "  ‚Ä¢ cargo check             - Check compilation"
fi

exit $EXIT_CODE
"#;

fn get_git_root() -> Result<PathBuf> {
    let output = std::process::Command::new("git")
        .args(["rev-parse", "--show-toplevel"])
        .output()?;

    if !output.status.success() {
        return Err(LintError::NotGitRepository);
    }

    let path = String::from_utf8_lossy(&output.stdout);
    Ok(PathBuf::from(path.trim()))
}

fn get_hooks_dir() -> Result<PathBuf> {
    let git_root = get_git_root()?;
    Ok(git_root.join(".git/hooks"))
}

fn get_hook_path(hook_name: &str) -> Result<PathBuf> {
    Ok(get_hooks_dir()?.join(hook_name))
}

pub async fn install_hooks(global: &crate::Global) -> Result<()> {
    if !global.is_silent() {
        aprintln!("{}", p_b("Installing git pre-commit hooks..."));
        aprintln!();
    }

    let git_root = get_git_root()?;
    if global.is_verbose() {
        aprintln!("{} Git repository: {}", p_b("Info:"), git_root.display());
    }

    let hooks_dir = get_hooks_dir()?;
    if !hooks_dir.exists() {
        if global.is_verbose() {
            aprintln!(
                "{} Creating hooks directory: {}",
                p_b("Info:"),
                hooks_dir.display()
            );
        }
        fs::create_dir_all(&hooks_dir)?;
    }

    install_hook("pre-commit", HOOK_TEMPLATE, global)?;

    aprintln!();
    aprintln!(
        "{} {}",
        p_g("‚úÖ"),
        p_g("Git hooks installation completed successfully!")
    );
    aprintln!();
    if !global.is_silent() {
        aprintln!("{}", p_b("The following hooks are now active:"));
        aprintln!(
            "  ‚Ä¢ {}: Runs cargo fmt, check, clippy, test, and file-length check",
            p_c("pre-commit")
        );
        aprintln!();
        aprintln!("{}", p_b("You can check hook status anytime with:"));
        aprintln!("  {}", p_c("cargo xtask lint --hooks-status"));
    }

    Ok(())
}

fn install_hook(hook_name: &str, template: &str, global: &crate::Global) -> Result<()> {
    let hook_path = get_hook_path(hook_name)?;

    if global.is_verbose() {
        aprintln!("{} Installing {} hook...", p_b("Info:"), hook_name);
    }

    if hook_path.exists() {
        backup_existing_hook(&hook_path, global)?;
    }

    fs::write(&hook_path, template)?;

    #[cfg(unix)]
    {
        let mut perms = fs::metadata(&hook_path)?.permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&hook_path, perms)?;
    }

    if !global.is_silent() {
        aprintln!("{} {} hook installed", p_g("‚úÖ"), hook_name);
    }

    Ok(())
}

fn backup_existing_hook(hook_path: &Path, global: &crate::Global) -> Result<()> {
    if let Ok(content) = fs::read_to_string(hook_path) {
        if content.contains("Generated by: cargo xtask lint --install-hooks") {
            if global.is_verbose() {
                aprintln!("{} Overwriting existing xtask hook", p_b("Info:"));
            }
            return Ok(());
        }
    }

    let timestamp = chrono::Utc::now().format("%Y%m%d_%H%M%S");
    let backup_path = hook_path.with_extension(format!("backup.{timestamp}"));

    if global.is_verbose() {
        aprintln!(
            "{} Backing up existing hook to: {}",
            p_y("‚ö†Ô∏è"),
            backup_path.display()
        );
    }

    fs::rename(hook_path, &backup_path)?;

    Ok(())
}

pub async fn uninstall_hooks(global: &crate::Global) -> Result<()> {
    if !global.is_silent() {
        aprintln!("{}", p_b("Uninstalling git pre-commit hooks..."));
        aprintln!();
    }

    let mut removed_count = 0;

    if let Ok(hook_path) = get_hook_path("pre-commit") {
        if hook_path.exists() {
            if let Ok(content) = fs::read_to_string(&hook_path) {
                if content.contains("Generated by: cargo xtask lint --install-hooks") {
                    if global.is_verbose() {
                        aprintln!("{} Removing pre-commit hook...", p_b("Info:"));
                    }
                    fs::remove_file(&hook_path)?;
                    aprintln!("{} {} hook removed", p_g("‚úÖ"), "pre-commit");
                    removed_count += 1;
                } else {
                    aprintln!(
                        "{} {} exists but is not our hook (skipping)",
                        p_y("‚ö†Ô∏è"),
                        "pre-commit"
                    );
                }
            }
        }
    }

    if removed_count > 0 {
        aprintln!();
        aprintln!("{} Removed {} hooks", p_g("Success:"), removed_count);
    } else {
        aprintln!("{}", p_b("No xtask hooks to remove"));
    }

    Ok(())
}

pub async fn show_status() -> Result<()> {
    aprintln!("{}", p_b("Git hooks status:"));
    aprintln!();

    let hook_name = "pre-commit";
    let hook_path = get_hook_path(hook_name)?;

    print!("  {:<15} ", format!("{hook_name}:"));

    if hook_path.exists() {
        if let Ok(content) = fs::read_to_string(&hook_path) {
            if content.contains("Generated by: cargo xtask lint --install-hooks") {
                aprintln!("{}", p_g("‚úÖ Installed"));
            } else {
                aprintln!("{}", p_y("‚ö†Ô∏è  Exists (not our hook)"));
            }
        } else {
            aprintln!("{}", p_y("‚ö†Ô∏è  Exists (cannot read)"));
        }
    } else {
        aprintln!("{}", p_r("‚ùå Not installed"));
    }

    aprintln!();
    aprintln!("{}", p_b("Available hooks:"));
    aprintln!(
        "  ‚Ä¢ {}: Runs cargo fmt, check, clippy, test, and file-length check before each commit",
        p_c("pre-commit")
    );
    aprintln!("                Supports --force flag to check all Rust files");
    aprintln!();
    aprintln!("{}", p_b("To install hooks:"));
    aprintln!("  {}", p_c("cargo xtask lint --install-hooks"));

    Ok(())
}

pub async fn test_hooks() -> Result<()> {
    aprintln!("{}", p_b("Testing git pre-commit hooks..."));
    aprintln!();

    let hook_path = get_hook_path("pre-commit")?;

    if !hook_path.exists() {
        aprintln!(
            "{} {} hook not found or not executable",
            p_r("‚ùå"),
            "pre-commit"
        );
        aprintln!();
        aprintln!("{}", p_b("To install hooks:"));
        aprintln!("  {}", p_c("cargo xtask lint --install-hooks"));
        return Err(LintError::HooksInstallFailed(
            "pre-commit hook not installed".to_string(),
        ));
    }

    aprintln!("{} Testing pre-commit hook (force mode)...", p_b("Info:"));
    aprintln!();

    let status = tokio::process::Command::new(&hook_path)
        .arg("--force")
        .status()
        .await?;

    aprintln!();
    if status.success() {
        aprintln!("{} {} hook test passed", p_g("‚úÖ"), "pre-commit");
    } else {
        aprintln!("{} {} hook test had issues", p_y("‚ö†Ô∏è"), "pre-commit");
        aprintln!(
            "{}",
            p_b("This might indicate code quality issues that need to be fixed")
        );
    }

    aprintln!();
    aprintln!("{}", p_b("Hook supports the following options:"));
    aprintln!("  ‚Ä¢ {}: Only checks staged .rs files", p_c("Normal mode"));
    aprintln!(
        "  ‚Ä¢ {}: Checks all .rs files in project",
        p_c("--force mode")
    );

    Ok(())
}
